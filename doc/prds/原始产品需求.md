好的，这是一个基于您想法整理的产品需求文档，重点关注了可实现性，并包含了 Mermaid 图以帮助开发团队理解。

## Git 增强工具产品需求文档

### 1. 引言

#### 1.1 项目概述
本项目旨在开发一款基于 Rust 和 Clap 的 Git 扩展工具，通过集成人工智能（AI）和代码扫描功能，增强现有的 Git 命令行体验，提高开发效率和代码质量。

#### 1.2 项目目标
*   通过 `git-enhancer` 的 `--ai` 标志激活 AI 功能，实现：
    *   自动生成规范的 Git Commit Message。
    *   对用户指定的 Git 命令进行 AI 解释。
*   在 `git add` 阶段集成代码扫描能力，提前发现潜在问题。
*   优化提交流程，将代码扫描结果与 Commit 信息关联。
*   提供灵活的配置选项，并确保工具的易用性和可扩展性。

#### 1.3 目标用户
所有使用 Git 进行版本控制的开发者。

### 2. 功能需求

#### 2.1 AI 辅助 Git Commit

*   **需求描述**：用户在使用 `git-enhancer` 执行 Git Commit 相关操作时，可以通过添加 `--ai` 参数给 `git-enhancer`，让工具自动生成 Commit Message。
*   **实现逻辑**：
    1.  当用户执行 `git-enhancer --ai commit <other_git_commit_args>` 时，工具解析到自身的 `--ai` 标志以及 `commit` 子命令。
    2.  工具执行 `git diff --staged`（或类似命令）获取已暂存的代码变更内容。
    3.  将获取到的代码变更信息发送给配置好的人工智能服务（如 OpenAI API），并附带一个用于生成 commit message 的系统提示。
    4.  AI 服务根据代码变更生成符合规范的 Commit Message。
    5.  工具使用 AI 生成的 Message，并结合用户提供的 `<other_git_commit_args>`（如 `-S` 等），执行 `git commit -m "<generated_message>" <other_git_commit_args>`。
*   **相关配置**：AI 服务地址、API Key、模型选择、Commit Message 生成提示等（详见配置管理章节）。
*   **命令行示例**：
    *   `git-enhancer --ai commit`
    *   `git-enhancer --ai commit -S` (如果用户需要GPG签名)
    *   `git-enhancer --ai commit --amend` (用户提供的原始信息可以作为 AI 生成的补充或参考，或在 amend 场景下由 AI 基于现有 diff 生成新 message)

#### 2.2 Git Add 集成代码扫描

*   **需求描述**：用户在执行 `git add` 命令时，可以通过添加 `--scan` 参数，触发对本次改动代码的自动扫描。
*   **实现逻辑**：
    1.  当用户执行 `git add <files> --scan` 时，工具在执行标准的 `git add` 操作后，启动代码扫描流程。
    2.  工具将当前仓库的代码（或根据 `<files>` 确定扫描范围）打包压缩。
    3.  通过 HTTP POST 请求将压缩包发送到用户配置的代码扫描系统。
    4.  在本地（如项目根目录下的 `.git/.scan_info` 或用户指定位置）创建一个跟踪文件，记录以下信息：
        *   扫描任务 ID（如果扫描系统返回）。
        *   扫描状态（例如：`pending`, `in_progress`, `completed`, `failed`）。
        *   发起扫描的时间戳。
        *   关联的 Git Commit 哈希（初始为空，在 Commit 后更新）。
*   **相关配置**：代码扫描系统地址、认证方式、打包范围配置等。
*   **命令行示例**：`git add . --scan`

#### 2.3 Commit 流程与代码扫描结果联动

*   **需求描述**：用户执行 `git commit` 时，如果检测到存在由 `--scan` 触发且尚未完成或未关联到 Commit 的扫描任务，应提示用户并允许用户等待扫描结果。
*   **实现逻辑**：
    1.  当用户执行 `git commit`（无论是否带 `--ai` 参数）时，工具检查本地是否存在活动的扫描跟踪文件。
    2.  **如果存在活动的扫描任务**（例如状态为 `pending` 或 `in_progress`）：
        *   向用户提示：“检测到正在进行的代码扫描任务。是否等待扫描结果并将其信息包含在 Commit Message 中？(yes/no/details)”。
        *   如果用户选择 `yes`：工具将轮询代码扫描系统获取最新状态。获取成功后，可以将扫描结果摘要或链接提供给用户，或（如果使用 `--ai`）作为附加上下文信息提供给 AI 生成 Commit Message。
        *   如果用户选择 `no`：继续执行 Commit 流程，不等待扫描结果。
        *   如果用户选择 `details`：显示当前扫描任务的详细状态。
    3.  **如果扫描任务已完成但未关联 Commit**：
        *   提示用户可以将扫描结果（如问题摘要、通过状态）包含在 Commit Message 中。
    4.  Commit 成功后，更新扫描跟踪文件，将当前 Commit 的哈希值与对应的扫描任务关联起来。

#### 2.4 配置文件管理

*   **需求描述**：工具应支持通过配置文件进行个性化设置，并在首次使用时自动创建和配置。
*   **实现逻辑**：
    1.  **配置文件位置**：在代码仓库的根目录下，例如 `.git_enhancer_config.toml`。
    2.  **自动创建**：当工具首次在项目中执行或未找到配置文件时，自动创建一个包含默认设置的配置文件。
    3.  **.gitignore 集成**：首次创建配置文件时，自动将该配置文件名添加到项目的 `.gitignore` 文件中，以避免将本地配置（尤其是 API 密钥等敏感信息）提交到仓库。
    4.  **配置内容示例**：
        ```toml
        [ai]
        # AI 服务提供商，例如 "openai", "gemini" 等
        provider = "openai"
        api_key = "YOUR_OPENAI_API_KEY" # 提示用户填写
        model = "gpt-3.5-turbo"
        # 生成 commit message 的 prompt 模板等
        commit_message_prompt = "Generate a concise git commit message in conventional commit format for the following changes:"

        [code_scan]
        # 代码扫描系统地址
        endpoint = "https://your.codescan.server/api/scan"
        # 认证 Token 或其他凭证
        auth_token = "YOUR_SCAN_AUTH_TOKEN" # 提示用户填写
        # 扫描历史/跟踪文件路径，相对于 .git 目录
        tracking_file = ".scan_info"

        [history]
        # 用于记录扫描历史的定位点等，例如上次扫描的commit
        last_scanned_commit = ""
        ```
    5.  **配置加载**：工具启动时加载配置文件，优先使用项目级配置。未来可考虑支持用户级的全局配置。

#### 2.5 AI 驱动的 Git 命令解释与辅助

*   **需求描述**：用户通过 `git-enhancer` 调用 Git 命令时，可以通过一个全局的 `--ai` 标志来获取 AI 辅助。根据 `--ai` 标志的存在以及后续参数中是否包含帮助标志（`-h` 或 `--help`），`git-enhancer` 会提供不同类型的 AI 辅助，包括解释 Git 命令的帮助输出或解释特定 Git 命令的功能。此功能也需要与 `git-enhancer` 现有的特定 AI 子命令（如 `commit --ai`）正确集成。

*   **核心逻辑与行为**：

    *   **参数处理概述**：
        1.  工具首先扫描传递给 `git-enhancer` 的所有原始命令行参数。
        2.  识别参数中**第一个出现**的 `--ai` 标志。这个 `--ai` 作为“全局 AI 模式”的开关。
        3.  如果找到了全局 `--ai`，则后续处理的参数（称为 `effective_command_args`）是除去这个全局 `--ai` 之外的所有原始参数，并保持它们原有的相对顺序。任何在此全局 `--ai` *之后* 出现的 `--ai` 标志都被视为 `effective_command_args` 的一部分。
        4.  如果未找到全局 `--ai`，则所有原始参数将由 `git-enhancer` 的子命令系统处理或直接透传给原生 Git。

    *   **场景化行为**：

        *   **场景 A：全局 `--ai` 标志存在**
            *   `effective_command_args` 是除去第一个全局 `--ai` 后的其余参数。

            *   **子场景 A.1：`effective_command_args` 包含 `-h` 或 `--help`**
                *   **动作**：
                    1.  `git-enhancer` 构建并执行由 `git` 加上 `effective_command_args` 构成的 Git 命令。
                    2.  捕获该命令的标准输出（即帮助文本）。
                    3.  将捕获到的帮助文本发送给 AI 服务进行解释。
                    4.  向用户显示 AI 生成的解释。
                *   **主要目标**：解释 Git 命令的标准帮助输出。

            *   **子场景 A.2：`effective_command_args` 不包含 `-h` 或 `--help`**
                *   `git-enhancer` 首先尝试将 `effective_command_args` 解析为其自身的特定子命令（例如 `commit`）。
                *   **情况 A.2.i：成功解析为 `git-enhancer` 子命令，并且该子命令实例本身表明需要 AI 操作。**
                    *   这通常意味着 `effective_command_args` 匹配了一个已定义的 `git-enhancer` 子命令（如 `commit`），并且该子命令的参数中包含了其自身的 AI 特定标志（例如，`CommitArgs` 结构体的 `ai` 字段因 `commit` 命令自身的 `--ai` 参数而被设为 `true`）。
                    *   **动作**：执行该 `git-enhancer` 子命令的特定 AI 功能（例如，AI 辅助生成提交信息）。
                *   **情况 A.2.ii：其他情况。**（包括：`effective_command_args` 未能解析为已知的 `git-enhancer` 子命令，或者虽然解析为 `git-enhancer` 子命令但该特定实例并未指明要执行该子命令自身的 AI 操作）。
                    *   **动作**：全局 `--ai` 标志的存在表明用户希望 AI 解释由 `git` 加上 `effective_command_args` 所代表的 Git 命令。
                        1.  将这些 `effective_command_args` 发送给 AI 服务，以解释该命令的目的、用法和行为。
                        2.  显示 AI 生成的解释。
                    *   **主要目标**：解释特定 Git 命令（及其选项）的作用。

        *   **场景 B：全局 `--ai` 标志不存在**
            *   `git-enhancer` 尝试将其后的所有参数解析为其自身的特定子命令。
            *   **子场景 B.1：参数成功解析为 `git-enhancer` 的特定子命令。**
                *   **动作**：执行该 `git-enhancer` 子命令定义的逻辑。这包括处理其自身的标志。例如，`git-enhancer commit --ai` 会触发 AI 信息生成，而 `git-enhancer commit -m "message"` 会执行标准的提交流程（可能是透传）。
            *   **子场景 B.2：参数未能解析为 `git-enhancer` 的特定子命令。**
                *   **动作**：所有提供的参数都直接传递给系统的原生 `git` 命令执行。`git-enhancer` 充当简单的透传工具。

*   **命令行示例**：
    *   **解释 Git 帮助输出**：
        *   `git-enhancer --ai status --short --help`
        *   `git-enhancer status --ai --help -s`
            *   （两者都会执行 `git status --short --help`，捕获其输出，并让 AI 解释该输出。）
    *   **解释 Git 命令功能 (全局 AI)**：
        *   `git-enhancer --ai log --oneline -n 5`
            *   （AI 解释 `git log --oneline -n 5` 的作用。）
        *   `git-enhancer --ai commit -m "一个标准提交信息"`
            *   （AI 解释 `git commit -m "一个标准提交信息"` 的作用，因为这里的 `commit` 子命令并未激活其内部的 AI 标志。）
    *   **通过全局 AI 触发 `git-enhancer` 子命令的特定 AI 功能**：
        *   `git-enhancer --ai commit --ai --all`
            *   （检测到全局 `--ai`。剩余的 `commit --ai --all` 被解析。`commit` 子命令自身的 `--ai` 标志被激活，触发对所有更改的 AI 提交信息生成。）
    *   **直接触发 `git-enhancer` 子命令的特定 AI 功能**：
        *   `git-enhancer commit --ai -m "让 AI 为此消息生成内容"`
            *   （无全局 `--ai`。解析为 `commit` 子命令。`commit` 子命令的 `--ai` 标志被激活，触发 AI 提交信息生成。）
    *   **标准的 `git-enhancer` 子命令用法 (commit 的非 AI 透传)**：
        *   `git-enhancer commit -m "我的特定消息"`
            *   （无全局 `--ai`。解析为 `commit` 子命令。其内部的 `--ai` 未激活。`git-enhancer` 继续其标准提交流程，很可能透传给 `git commit -m "我的特定消息"`。）
    *   **标准 Git 命令透传**：
        *   `git-enhancer status -s`
        *   `git-enhancer branch my-new-branch`
            *   （无全局 `--ai`。该命令不是已知的 `git-enhancer` 特定子命令。命令及其参数被直接传递给系统的 `git`。）
    *   **处理多个 `--ai` 标志**：
        *   `git-enhancer --ai status --ai --short --help`
            *   第一个 `--ai` 触发全局 AI 模式。
            *   `effective_command_args` = `["status", "--ai", "--short", "--help"]`。
            *   包含 `--help`。
            *   AI 解释 `git status --ai --short --help` 的输出。
        *   `git-enhancer commit --ai --ai -m "test"`
            *   初始无全局 `--ai`。
            *   这被解析为 `git-enhancer commit`，参数为 `["--ai", "--ai", "-m", "test"]`。
            *   `commit` 子命令的解析器会看到其自身的 `--ai` 标志（其参数中遇到的第一个）并可能激活 AI 信息生成。第二个特定于 commit 的 `--ai` 可能会因 `CommitArgs` 的定义而被 clap 视为错误或忽略。此特定情况取决于 `CommitArgs` 如何处理多个相同的布尔标志。假设采用标准的 `clap` 行为，`commit` 子命令解析器遇到的第一个 `--ai` 会激活其 AI 模式。

### 3. 技术选型与架构

#### 3.1 核心技术
*   **编程语言**：Rust。
*   **命令行参数解析**：Clap 库。

#### 3.2 架构设计
*   **模块化**：代码结构应清晰划分，例如分为命令行处理模块、Git 交互模块、AI 服务模块、代码扫描模块、配置管理模块。
*   **可扩展性**：设计时应考虑到未来功能的扩展，例如支持新的 AI 服务、新的代码扫描工具或新的 Git 子命令增强。Clap 允许通过组合不同的参数结构体来方便地扩展命令行接口。

### 4. 工作流程图 (Mermaid)

#### 4.1 AI 辅助 Commit (`git-enhancer --ai commit`) 流程

```mermaid
graph TD
    A[用户执行: git-enhancer --ai commit <args>] --> B{工具解析 --ai 和 commit 命令};
    B --> C[执行 'git diff --staged'];
    C --> D[捕获暂存区代码变更];
    D --> E[将变更信息和 Commit 提示发送至配置的 AI 服务];
    E --> F[AI 服务生成 Commit Message];
    F --> G[工具接收 Commit Message];
    G --> H[执行 'git commit -m "AI 生成的 Message" <args>'];
    H --> I[Commit 完成];
```

#### 4.2 代码扫描与 Commit 联动流程 (`git add --scan` 后接 `git commit`)

```mermaid
graph TD
    subgraph Git Add 阶段
        AA[用户执行: git add <files> --scan] --> AB{工具拦截命令};
        AB --> AC[执行 'git add <files>'];
        AC --> AD[打包仓库代码 (或指定文件)];
        AD --> AE[通过 POST 请求发送至代码扫描系统];
        AE --> AF[创建/更新本地扫描跟踪文件 (状态: pending, 扫描ID)];
    end

    subgraph Git Commit 阶段
        CA[用户执行: git commit] --> CB{工具拦截命令};
        CB --> CC{检查是否存在活动的扫描跟踪文件?};
        CC -- 是 --> CD{扫描任务进行中?};
        CD -- 是 --> CE[提示用户: 是否等待扫描结果?];
        CE -- 是 --> CF[轮询扫描系统获取状态/结果];
        CF -- 扫描完成 --> CG[获取扫描结果];
        CG --> CH[可选: 将扫描结果纳入 Commit Message (手动或通过AI)];
        CH --> CI[执行实际的 'git commit'];
        CD -- 否/已完成 --> CG;
        CE -- 否 --> CI;
        CC -- 否 --> CI;
        CI -- Commit 成功 --> CJ[更新扫描跟踪文件, 关联 Commit 哈希];
        CJ --> CK[Commit 完成];
    end
```

#### 4.3 AI 驱动的 Git 命令解释与辅助流程

```mermaid
graph TD
    A[用户执行: git-enhancer [--ai] <git_command_parts...>] --> B{检测到全局 --ai 标志? (第一个 --ai)};
    B -- 是 --> GlobalAIMode{全局 AI 模式};
    GlobalAIMode --> ArgsForAI[获取 `effective_command_args` (移除第一个 --ai)];
    ArgsForAI --> C{`effective_command_args` 中是否包含 --help 或 -h?};
    C -- 是 --> E[构造并执行: git `<effective_command_args>`];
    E --> CaptureOutput[捕获标准输出 (帮助文本)];
    CaptureOutput --> F[将帮助文本发送至 AI 服务解释];
    F --> G[AI 服务生成命令解释];
    G --> H[工具接收解释文本];
    H --> I[将解释输出到终端];
    I --> J[流程结束];
    C -- 否 --> AttemptSubcommandParse{尝试将 `effective_command_args` 解析为 `git-enhancer` 子命令};
    AttemptSubcommandParse -- 成功且子命令触发自身AI (如 commit --ai) --> K[执行 `git-enhancer` 子命令的特定AI功能];
    K --> J;
    AttemptSubcommandParse -- 失败或子命令不触发自身AI --> L[将 `effective_command_args` 发送至 AI 服务解释命令功能];
    L --> G;

    B -- 否 (无全局 --ai) --> NoGlobalAIMode{标准模式};
    NoGlobalAIMode --> ParseAsGESubcommand{尝试将所有参数解析为 `git-enhancer` 子命令};
    ParseAsGESubcommand -- 成功 --> M[执行 `git-enhancer` 子命令逻辑 (可能含其自身 --ai)];
    M --> J;
    ParseAsGESubcommand -- 失败 --> N[将所有参数透传给原生 `git` 执行];
    N --> J;
```

### 5. 非功能性需求

*   **性能**：工具的执行不应显著拖慢正常的 Git 操作。
*   **易用性**：清晰的命令行提示和错误信息。
*   **安全性**：妥善处理 API Key 等敏感信息，避免硬编码，并通过 `.gitignore` 防止泄露。
*   **兼容性**：尽可能兼容主流操作系统（Windows, macOS, Linux）。

### 6. 未来展望（本次迭代范围外）
*   支持更多的 AI 服务提供商。
*   集成多种代码扫描工具。
*   提供更丰富的扫描结果展示和交互。
*   通过 Git Hooks 实现更自动化的流程（例如 pre-commit 自动扫描）。
*   支持更细致的扫描范围配置。

希望这份产品需求文档能够帮助您清晰地规划和开发这款 Git 增强工具。
